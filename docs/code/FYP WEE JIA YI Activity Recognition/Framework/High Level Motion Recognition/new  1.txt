import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Scanner;

//THINGS TO DO 09/02
/*1. get new SMA data from matlab
 2.  improve smoothing function
 3. determine sma peak for all possible transition
 4. add new HLM to code
 */
public class Main {

	static ArrayList<inputClass> inputData =new ArrayList<inputClass>();
	static ArrayList<inputClass> outputData =new ArrayList<inputClass>();
	static int transitionFlag=0;
	static int globalIndex=0;
	
	public static void loadinput (String fileName){
		try {
			Scanner in = new Scanner(new File(fileName));
			while (in.hasNext()){
				String ssma= in.next();
				String activity= in.next();
				double sma=Double.parseDouble(ssma);
				int act = Integer.parseInt(activity);
				inputData.add(new inputClass(sma, act));
			}
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	public static void cleanUp (){
		for (int u=0; u<inputData.size(); u++){
			if (inputData.get(u).getsma() > 8) inputData.get(u).setact(2) ; 
		}//sit has SMA>8 consistently
	}
	
	public static void writeoutput (ArrayList<inputClass> window) throws IOException{
		BufferedWriter writer1 = new BufferedWriter(new FileWriter("higherlevelmotion.csv"));
		try {
			for (int item=0; item<window.size(); item++){
				writer1.write(String.valueOf(window.get(item).getact()));
				writer1.write("\t");
				writer1.newLine();
				writer1.flush();
			}
		}catch(IOException ex) {
		    ex.printStackTrace();
		}finally{
			if (writer1!=null){
				writer1.close();
			}
		}	
	}
	
	public static double[] smaPeakdetermination(inputClass[] window){
		//answer[0]:SMAPeak1 
		//answer[1]:SMAPeak1's index
		//answer[2]:SMAPeak2 
		//answer[3]:SMAPeak2's index
		double[] answer = new double[4];
		answer[0]=window[0].getsma(); answer[2]=window[1].getsma();
		answer[1]=0; answer[3]=1;
		if (window[1].getsma()>window[0].getsma()) {
			answer[0]=window[1].getsma(); answer[2]=window[0].getsma();
			answer[1]=1; answer[3]=0;}
		for (int t=2; t<5; t++){
			if (window[t].getsma()>answer[0]) {
				answer[2] = answer[0]; answer[0] = window[t].getsma(); 
				answer[1]=t;answer[3]=0;
			}
			if (window[t].getsma()<answer[0] && window[t].getsma()>answer[2]) {
				answer[2] = window[t].getsma();
				answer[3]=t;
			}
		}
		return answer;
	}
	
	public static void fallDetection (inputClass[] window, double threshold){
		//ans[0]:SMAPeak1	ans[1]:SMAPeak1's index		ans[2]:SMAPeak2		ans[3]:SMAPeak2's index
		double[] ans= smaPeakdetermination(window);
		//Determine if SMA peaks are adjacent
		if (Math.abs(ans[1]-ans[3])==1 && ans[0]>threshold && ans[2]>threshold){// ACTUAL FALL DOWN
			for (int y=1; y<4; y++){
				window[y].setact(6);
			}
		}
		else{//FAKE FALL DOWN
			//1. normal lying down
			if (window[0].getact()==2) sitTOlyingDetection(window,1);
			//2. dirty data (smoothing require)
			transitionFlag=0;
		}
		for (int y=0; y<5;y++){
			System.out.println("output-fall");
			outputData.add(new inputClass(window[y].getsma(), window[y].getact()));
			inputData.get(y+globalIndex).setact(window[y].getact());
		}
	}
	// using a voting mechanism
	public static inputClass[] smoothing(inputClass[] window) {
		transitionFlag=0;
	    int maxKey = 0;
	    int maxCounts = 0;
	    int[] counts = new int[15]; //let this be the total number of HLM types
	    for (int i=0; i < 5; i++) {
	        counts[window[i].getact()]++;
	        //System.out.printf("i%d window item%d maxKey%d maxCounts%d\n", i, window[i].getact(), maxKey, maxCounts);
	        if (maxCounts < counts[window[i].getact()]) {
	            maxCounts = counts[window[i].getact()];
	            maxKey = window[i].getact();
	        }
	        System.out.printf("i%d window item%d maxKey%d maxCounts%d\n", i, window[i].getact(), maxKey, maxCounts);
	    } System.out.printf("mode is%d with %d number of times",maxKey, maxCounts);
	    for (int i=0; i<window.length; i++){
	    	if (window[i].getact()!=maxKey){
	    		window[i].setact(maxKey);
	    		inputData.get(i+globalIndex).setact(window[i].getact());
	    	}
	    	
	    }
		return window;
	}

	public static void sitTOlyingDetection(inputClass[] window, double threshold) {
		double[] ans= smaPeakdetermination(window);
		//Actual Lying-Down (PeakSMA>threshold)
		if (ans[0]>threshold) { 
			for (int y=1; y<4; y++){
				window[y].setact(7);
			}
		}
		else { //Fake Lying-Down, require smoothing
			transitionFlag=0;
		}
		for (int y=0; y<5;y++){
			System.out.println("output-sit2lying");
			outputData.add(new inputClass(window[y].getsma(), window[y].getact()));
			inputData.get(y+globalIndex).setact(window[y].getact());
		}
	}

	public static void lyingTOsitDetection(inputClass[] window, double threshold) {
		double[] ans= smaPeakdetermination(window);
		//Actual Sitting-Up (PeakSMA>threshold)
		if (ans[0]>threshold) { 
			for (int y=1; y<4; y++){
				window[y].setact(8);
			}
		}
		else { //Fake Sitting-Up, require smoothing
			transitionFlag=0;
		}
		for (int y=0; y<5;y++){
			System.out.println("output-lying2sit");
			outputData.add(new inputClass(window[y].getsma(), window[y].getact()));
			inputData.get(y+globalIndex).setact(window[y].getact());
		}
	}

	public static void sitTOstandDetection(inputClass[] window, double threshold) {
		double[] ans= smaPeakdetermination(window);
		//Actual Stand-Up (PeakSMA>threshold)
		if (ans[0]>threshold) { 
			for (int y=1; y<4; y++){
				window[y].setact(9);
			}
		}
		else { //Fake Stand-Up, require smoothing
			transitionFlag=0;
		}
		for (int y=0; y<5;y++){
			System.out.println("output-sit2stand");
			outputData.add(new inputClass(window[y].getsma(), window[y].getact()));
			inputData.get(y+globalIndex).setact(window[y].getact());
		}
	}

	public static void standTOsitDetection(inputClass[] window, double threshold) {
		double[] ans= smaPeakdetermination(window);
		//Actual Sit-Down (PeakSMA>threshold)
		if (ans[0]>threshold) { 
			for (int y=1; y<4; y++){
				window[y].setact(10);
			}
		}
		else { //Fake Sit-Down, require smoothing
			transitionFlag=0;
		}	
		for (int y=0; y<5;y++){
			System.out.println("output-stand2sit");
			outputData.add(new inputClass(window[y].getsma(), window[y].getact()));
			inputData.get(y+globalIndex).setact(window[y].getact());
		}
	}
	
	public static void main(String[] arg) throws IOException{
		loadinput("input.txt");
		//cleanUp();
		while (globalIndex!=inputData.size()-5){
			transitionFlag=0;
			System.out.println("hi");
			inputClass window[] =new inputClass[5];
			for (int i=0;i<5;i++){
				System.out.println(i);
				window[i]= new inputClass (inputData.get(i+globalIndex).getsma(),inputData.get(i+globalIndex).getact());
			} //voting is not working...
			
			//second parameter is the SMA threshold (determine through experiment)
			//falling motion **normal Lying action (i.e. sit to lying is triggered from fallDetection)
			/*if(window[0].getact()!=1 && window[4].getact()==1) {
				fallDetection(window,9.8*1.8); //threshold according to report[8] TBC WITH TESTING
				transitionFlag=1; 
				System.out.println("Fall");
			}
			//stand-up motion
			if(window[0].getact()==2 && window[4].getact()==3) {//shld b exclusive
				sitTOstandDetection(window,0);
				transitionFlag=1;
				System.out.println("sit2stand");
			}
			//sit-down motion
			if(window[0].getact()==3 && window[4].getact()==2) {
				standTOsitDetection(window,0);
				transitionFlag=1;
				System.out.println("stand2sit");
			}
			//sit-up motion
			if(window[0].getact()==1 && window[4].getact()==2) {
				lyingTOsitDetection(window,0);
				transitionFlag=1;
				System.out.println("lying2sit");
			}*/
			//check for smoothing here also
			if (transitionFlag==0){ 
				window= smoothing(window);
				for (int y=0; y<5;y++){
					System.out.println("output-SmoothingMain");
					outputData.add(new inputClass(window[y].getsma(), window[y].getact()));
				}
				globalIndex+=1; //overlap 4 frame for next check
			}
			else globalIndex+=4; //overlap 1 frame for next check
			
		}
		System.out.println(outputData.size());
		writeoutput(outputData);
	}	
}
